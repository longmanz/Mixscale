end_idx <- idx_iter * nrow(mat)
null_pc[start_idx:end_idx, ] <- null_test$x[1:k]
}
dim(null_pc)
head(null_pc)
tail(null_pc)
head(null_test)
str(null_test)
null_test$x
head(null_test$x)
start_idx:end_idx
start_idx
end_idx
nrow(mat)
436806 + 2195
head(null_tmp )
head(mat)
head(null_test$x)
heaD(null_test$x[1:k])
head(null_test$x[1:k])
head(null_test$x[, 1:k])
head(null_test$x[, 1:k, drop = F])
# Perform iterations
for(idx_iter in 1:num_iter){
set.seed(idx_iter+500)
null_tmp = apply(mat, 2, sample)
null_test = prcomp(null_tmp, center = center, scale. = scale)
# Direct indexing to assign values
start_idx <- (idx_iter - 1) * nrow(mat) + 1
end_idx <- idx_iter * nrow(mat)
null_pc[start_idx:end_idx, ] <- null_test$x[, 1:k, drop = F]
}
class(null_pc)
head(null_pc)
PCApermtest = function(mat = NULL, k = 1, var_prop = 0.1,
center = T, scale = T,
num_iter = 200,
seed = 123124125,
...){
# set the random seed
set.seed(seed = seed)
# perform standard PCA (centering and scaling) for the input mat
test = prcomp(mat, center = center, scale. = scale)
# get the % of variance (which is sdev^2) explained for each PC
prop_test = test$sdev^2/sum(test$sdev^2)
# if k is not set, we will determine it based on the %var by each PC
if(is.null(k) & !is.null(var_prop)){
# we will only use those PCs with %var >= 10%
k = tail(which(prop_test >= var_prop), 1)
# check if none of the PC has %var >= prop_var.
if(length(k) == 0){
stop(paste("None of the PC has %var >=", var_prop, ". Please use a lower value."))
}
} else if (is.null(k) & is.null(var_prop)){
stop(paste("Neither k or var_prop is provided. Please specify one of them."))
}
# the permutation test
# Preallocate memory for null_pc
null_pc <- matrix(0, nrow = nrow(mat) * num_iter, ncol = k)
# Perform iterations
for(idx_iter in 1:num_iter){
set.seed(idx_iter+500)
null_tmp = apply(mat, 2, sample)
null_test = prcomp(null_tmp, center = center, scale. = scale)
# Direct indexing to assign values
start_idx <- (idx_iter - 1) * nrow(mat) + 1
end_idx <- idx_iter * nrow(mat)
null_pc[start_idx:end_idx, ] <- null_test$x[, 1:k, drop = F]
}
#### after getting the null distribution we will now move on to pval calculation
for(i in 1:ncol(null_pc)){
ecdf_fun = ecdf(null_pc[, i])
tmp_pval = sapply(X = test$x[, i], FUN = ecdf_fun)
if(i == 1){
pval = matrix(data = tmp_pval, ncol = 1)
} else {
pval = cbind(pval, tmp_pval)
}
}
colnames(pval) = paste0("PC", 1:ncol(null_pc))
rownames(pval) = rownames(mat)
return(list(mat = mat,
pmat = pval,
prcomp_obj = test))
}
PCApermtest = function(mat = NULL, k = 1, var_prop = 0.1,
center = T, scale = T,
num_iter = 200,
seed = 123124125,
...){
# set the random seed
set.seed(seed = seed)
# perform standard PCA (centering and scaling) for the input mat
test = prcomp(mat, center = center, scale. = scale)
# get the % of variance (which is sdev^2) explained for each PC
prop_test = test$sdev^2/sum(test$sdev^2)
# if k is not set, we will determine it based on the %var by each PC
if(is.null(k) & !is.null(var_prop)){
# we will only use those PCs with %var >= 10%
k = tail(which(prop_test >= var_prop), 1)
# check if none of the PC has %var >= prop_var.
if(length(k) == 0){
stop(paste("None of the PC has %var >=", var_prop, ". Please use a lower value."))
}
} else if (is.null(k) & is.null(var_prop)){
stop(paste("Neither k or var_prop is provided. Please specify one of them."))
}
# the permutation test
# Preallocate memory for null_pc
null_pc <- matrix(0, nrow = nrow(mat) * num_iter, ncol = k)
# Perform iterations
for(idx_iter in 1:num_iter){
# set.seed(idx_iter+500)
null_tmp = apply(mat, 2, sample)
null_test = prcomp(null_tmp, center = center, scale. = scale)
# Direct indexing to assign values
start_idx <- (idx_iter - 1) * nrow(mat) + 1
end_idx <- idx_iter * nrow(mat)
null_pc[start_idx:end_idx, ] <- null_test$x[, 1:k, drop = F]
}
#### after getting the null distribution we will now move on to pval calculation
for(i in 1:ncol(null_pc)){
ecdf_fun = ecdf(null_pc[, i])
tmp_pval = sapply(X = test$x[, i], FUN = ecdf_fun)
if(i == 1){
pval = matrix(data = tmp_pval, ncol = 1)
} else {
pval = cbind(pval, tmp_pval)
}
}
colnames(pval) = paste0("PC", 1:ncol(null_pc))
rownames(pval) = rownames(mat)
return(list(mat = mat,
pmat = pval,
prcomp_obj = test))
}
####  Run the PCApermtest()
res = PCApermtest(mat = tmp, k = 1, seed = 44)
sig_genes = get_sig_genes(perm_obj = res,collapse = F)
str(sig_genes)
length(topDEG_idx)
length(bottomDEG_idx)
plot(res$pmat, slct_pval)
abline(0, 1)
head(res$pmat)
head(slct_pval)
####  Run the PCApermtest()
res = PCApermtest(mat = tmp, k = 2)
sig_genes = get_sig_genes(perm_obj = res,collapse = F)
str(sig_genes)
sig_genes = get_sig_genes(perm_obj = res, k = 2, collapse = F)
get_sig_genes = function(perm_obj = NULL,
k = 1,
var_prop = NULL,
var_prop_total = NULL,
perm_pval_thres = 0.05,
ori_pval_thres = 1.666667e-06,
cor_threshold = 0.2,
collapse = T,
...){
# check if the object has the correct format
if(class(perm_obj$prcomp_obj) != "prcomp"){
stop("The input object does not contain the correct PCA obj from prcomp().")
}
# extract each element from the provided object
test = perm_obj$prcomp_obj
mat = perm_obj$mat
pval = perm_obj$pmat
# first we need to re-calculate the %var explained for each PC
prop_test = test$sdev^2/sum(test$sdev^2)
# if k is set then we will use the top k PCs.
# if not, we will determine the k based on the given var_prop or var_prop_total
#  note that if var_prop is set, var_prop_total will be ignored.
if(!is.null(k)){
max_PC_idx = k
} else if (is.null(k) & !is.null(var_prop)) {
idx1 = which(prop_test >= var_prop)
max_PC_idx = tail(idx1, 1)
} else if (is.null(k) & is.null(var_prop) & !is.null(var_prop_total)){
max_PC_idx = which( cumsum(prop_test) >= var_prop_total )[1]
} else {
stop("Please provide at least one of the following paramters: k, var_prop, var_prop_total.")
}
# do the selection
slct_pval = pval[, 1:max_PC_idx, drop = F]
# extract the sig elements for each PC
# note that pval_threshold is not the same as perm_pval_thres
pval_threshold = ori_pval_thres
z_threshold = sqrt(qchisq(pval_threshold, df=1, lower=F))
#
for(i in 1:max_PC_idx){
topDEG_idx = list()
bottomDEG_idx = list()
cor_test = cor(test$x[,i], mat)
# print(cor_test)
PRTB_idx = which(abs(cor_test) >= cor_threshold)
topDEG = which(slct_pval[, i] >= 1 - perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
topDEG = topDEG[order(test$x[topDEG, i], decreasing = T)]
bottomDEG = which(slct_pval[, i] <= perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
bottomDEG = bottomDEG[order(test$x[bottomDEG, i], decreasing = T)]
# determine the orientation by looking at the sums of Z-score
# a positive sum(Z-score) indicates up-regulated genes;
# a negative sum(Z-score) indicates down-regulated genes.
if( sum(mat[topDEG, PRTB_idx]) > sum(mat[bottomDEG, PRTB_idx]) ){
swap = topDEG
topDEG = rev(bottomDEG)
bottomDEG = rev(swap)
rm(swap)
}
topDEG_idx[[paste0("PC", i)]] = topDEG
bottomDEG_idx[[paste0("PC", i)]] = bottomDEG
}
# By default, if k >= 2, we will collapse all the significant genes together
#  and return it to users.
if(collapse == T){
topDEG_idx = Reduce(c, topDEG_idx)
topDEG_idx = topDEG_idx[!duplicated(topDEG_idx)]
bottomDEG_idx = rev(bottomDEG_idx)
bottomDEG_idx = Reduce(c, bottomDEG_idx)
bottomDEG_idx = bottomDEG_idx[!duplicated(bottomDEG_idx)]
return(list(downDEGs = rownames(mat)[topDEG_idx],
upDEGs = rownames(mat)[bottomDEG_idx]))
} else {
downDEGs = list()
upDEGs = list()
for(i in 1:max_PC_idx){
downDEGs[[names(topDEG_idx)[i]]] = rownames(mat)[topDEG_idx[[1]]]
upDEGs[[names(bottomDEG_idx)[i]]] = rev(rownames(mat)[bottomDEG_idx[[1]]])
}
return(list(downDEGs = downDEGs,
upDEGs = upDEGs))
}
}
sig_genes = get_sig_genes(perm_obj = res, k = 2, collapse = F)
str(sig_genes)
get_sig_genes = function(perm_obj = NULL,
k = 1,
var_prop = NULL,
var_prop_total = NULL,
perm_pval_thres = 0.05,
ori_pval_thres = 1.666667e-06,
cor_threshold = 0.2,
collapse = T,
...){
# check if the object has the correct format
if(class(perm_obj$prcomp_obj) != "prcomp"){
stop("The input object does not contain the correct PCA obj from prcomp().")
}
# extract each element from the provided object
test = perm_obj$prcomp_obj
mat = perm_obj$mat
pval = perm_obj$pmat
# first we need to re-calculate the %var explained for each PC
prop_test = test$sdev^2/sum(test$sdev^2)
# if k is set then we will use the top k PCs.
# if not, we will determine the k based on the given var_prop or var_prop_total
#  note that if var_prop is set, var_prop_total will be ignored.
if(!is.null(k)){
max_PC_idx = k
} else if (is.null(k) & !is.null(var_prop)) {
idx1 = which(prop_test >= var_prop)
max_PC_idx = tail(idx1, 1)
} else if (is.null(k) & is.null(var_prop) & !is.null(var_prop_total)){
max_PC_idx = which( cumsum(prop_test) >= var_prop_total )[1]
} else {
stop("Please provide at least one of the following paramters: k, var_prop, var_prop_total.")
}
# do the selection
slct_pval = pval[, 1:max_PC_idx, drop = F]
# extract the sig elements for each PC
# note that pval_threshold is not the same as perm_pval_thres
pval_threshold = ori_pval_thres
z_threshold = sqrt(qchisq(pval_threshold, df=1, lower=F))
#
for(i in 1:max_PC_idx){
topDEG_idx = list()
bottomDEG_idx = list()
cor_test = cor(test$x[,i], mat)
# print(cor_test)
PRTB_idx = which(abs(cor_test) >= cor_threshold)
topDEG = which(slct_pval[, i] >= 1 - perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
topDEG = topDEG[order(test$x[topDEG, i], decreasing = T)]
bottomDEG = which(slct_pval[, i] <= perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
bottomDEG = bottomDEG[order(test$x[bottomDEG, i], decreasing = T)]
# determine the orientation by looking at the sums of Z-score
# a positive sum(Z-score) indicates up-regulated genes;
# a negative sum(Z-score) indicates down-regulated genes.
if( sum(mat[topDEG, PRTB_idx]) > sum(mat[bottomDEG, PRTB_idx]) ){
swap = topDEG
topDEG = rev(bottomDEG)
bottomDEG = rev(swap)
rm(swap)
}
topDEG_idx[[paste0("PC", i)]] = topDEG
bottomDEG_idx[[paste0("PC", i)]] = bottomDEG
}
# By default, if k >= 2, we will collapse all the significant genes together
#  and return it to users.
if(collapse == T){
topDEG_idx = Reduce(c, topDEG_idx)
topDEG_idx = topDEG_idx[!duplicated(topDEG_idx)]
bottomDEG_idx = rev(bottomDEG_idx)
bottomDEG_idx = Reduce(c, bottomDEG_idx)
bottomDEG_idx = bottomDEG_idx[!duplicated(bottomDEG_idx)]
return(list(downDEGs = rownames(mat)[topDEG_idx],
upDEGs = rownames(mat)[bottomDEG_idx]))
} else {
downDEGs = list()
upDEGs = list()
for(i in 1:max_PC_idx){
downDEGs[[names(topDEG_idx)[i]]] = rownames(mat)[topDEG_idx[[i]]]
upDEGs[[names(bottomDEG_idx)[i]]] = rev(rownames(mat)[bottomDEG_idx[[i]]])
}
return(list(downDEGs = downDEGs,
upDEGs = upDEGs))
}
}
str(res)
sig_genes = get_sig_genes(perm_obj = res, k = 2, collapse = F)
max_PC_idx
k=2
perm_obj = res
# check if the object has the correct format
if(class(perm_obj$prcomp_obj) != "prcomp"){
stop("The input object does not contain the correct PCA obj from prcomp().")
}
# extract each element from the provided object
test = perm_obj$prcomp_obj
mat = perm_obj$mat
pval = perm_obj$pmat
# first we need to re-calculate the %var explained for each PC
prop_test = test$sdev^2/sum(test$sdev^2)
prop_test
# if k is set then we will use the top k PCs.
# if not, we will determine the k based on the given var_prop or var_prop_total
#  note that if var_prop is set, var_prop_total will be ignored.
if(!is.null(k)){
max_PC_idx = k
} else if (is.null(k) & !is.null(var_prop)) {
idx1 = which(prop_test >= var_prop)
max_PC_idx = tail(idx1, 1)
} else if (is.null(k) & is.null(var_prop) & !is.null(var_prop_total)){
max_PC_idx = which( cumsum(prop_test) >= var_prop_total )[1]
} else {
stop("Please provide at least one of the following paramters: k, var_prop, var_prop_total.")
}
max_PC_idx
# do the selection
slct_pval = pval[, 1:max_PC_idx, drop = F]
# extract the sig elements for each PC
# note that pval_threshold is not the same as perm_pval_thres
pval_threshold = ori_pval_thres
perm_pval_thres = 0.05
ori_pval_thres = 1.666667e-06
cor_threshold = 0.2
# if k is set then we will use the top k PCs.
# if not, we will determine the k based on the given var_prop or var_prop_total
#  note that if var_prop is set, var_prop_total will be ignored.
if(!is.null(k)){
max_PC_idx = k
} else if (is.null(k) & !is.null(var_prop)) {
idx1 = which(prop_test >= var_prop)
max_PC_idx = tail(idx1, 1)
} else if (is.null(k) & is.null(var_prop) & !is.null(var_prop_total)){
max_PC_idx = which( cumsum(prop_test) >= var_prop_total )[1]
} else {
stop("Please provide at least one of the following paramters: k, var_prop, var_prop_total.")
}
# do the selection
slct_pval = pval[, 1:max_PC_idx, drop = F]
head(slct_pval)
# extract the sig elements for each PC
# note that pval_threshold is not the same as perm_pval_thres
pval_threshold = ori_pval_thres
z_threshold = sqrt(qchisq(pval_threshold, df=1, lower=F))
#
for(i in 1:max_PC_idx){
topDEG_idx = list()
bottomDEG_idx = list()
cor_test = cor(test$x[,i], mat)
# print(cor_test)
PRTB_idx = which(abs(cor_test) >= cor_threshold)
topDEG = which(slct_pval[, i] >= 1 - perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
topDEG = topDEG[order(test$x[topDEG, i], decreasing = T)]
bottomDEG = which(slct_pval[, i] <= perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
bottomDEG = bottomDEG[order(test$x[bottomDEG, i], decreasing = T)]
# determine the orientation by looking at the sums of Z-score
# a positive sum(Z-score) indicates up-regulated genes;
# a negative sum(Z-score) indicates down-regulated genes.
if( sum(mat[topDEG, PRTB_idx]) > sum(mat[bottomDEG, PRTB_idx]) ){
swap = topDEG
topDEG = rev(bottomDEG)
bottomDEG = rev(swap)
rm(swap)
}
topDEG_idx[[paste0("PC", i)]] = topDEG
bottomDEG_idx[[paste0("PC", i)]] = bottomDEG
}
str(topDEG_idx)
i
###
topDEG_idx = list()
bottomDEG_idx = list()
for(i in 1:max_PC_idx){
cor_test = cor(test$x[,i], mat)
# print(cor_test)
PRTB_idx = which(abs(cor_test) >= cor_threshold)
topDEG = which(slct_pval[, i] >= 1 - perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
topDEG = topDEG[order(test$x[topDEG, i], decreasing = T)]
bottomDEG = which(slct_pval[, i] <= perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
bottomDEG = bottomDEG[order(test$x[bottomDEG, i], decreasing = T)]
# determine the orientation by looking at the sums of Z-score
# a positive sum(Z-score) indicates up-regulated genes;
# a negative sum(Z-score) indicates down-regulated genes.
if( sum(mat[topDEG, PRTB_idx]) > sum(mat[bottomDEG, PRTB_idx]) ){
swap = topDEG
topDEG = rev(bottomDEG)
bottomDEG = rev(swap)
rm(swap)
}
topDEG_idx[[paste0("PC", i)]] = topDEG
bottomDEG_idx[[paste0("PC", i)]] = bottomDEG
}
str(topDEG_idx)
str(bottomeDEG_idx)
str(bottomDEG_idx)
get_sig_genes = function(perm_obj = NULL,
k = 1,
var_prop = NULL,
var_prop_total = NULL,
perm_pval_thres = 0.05,
ori_pval_thres = 1.666667e-06,
cor_threshold = 0.2,
collapse = T,
...){
# check if the object has the correct format
if(class(perm_obj$prcomp_obj) != "prcomp"){
stop("The input object does not contain the correct PCA obj from prcomp().")
}
# extract each element from the provided object
test = perm_obj$prcomp_obj
mat = perm_obj$mat
pval = perm_obj$pmat
# first we need to re-calculate the %var explained for each PC
prop_test = test$sdev^2/sum(test$sdev^2)
# if k is set then we will use the top k PCs.
# if not, we will determine the k based on the given var_prop or var_prop_total
#  note that if var_prop is set, var_prop_total will be ignored.
if(!is.null(k)){
max_PC_idx = k
} else if (is.null(k) & !is.null(var_prop)) {
idx1 = which(prop_test >= var_prop)
max_PC_idx = tail(idx1, 1)
} else if (is.null(k) & is.null(var_prop) & !is.null(var_prop_total)){
max_PC_idx = which( cumsum(prop_test) >= var_prop_total )[1]
} else {
stop("Please provide at least one of the following paramters: k, var_prop, var_prop_total.")
}
# do the selection
slct_pval = pval[, 1:max_PC_idx, drop = F]
# extract the sig elements for each PC
# note that pval_threshold is not the same as perm_pval_thres
pval_threshold = ori_pval_thres
z_threshold = sqrt(qchisq(pval_threshold, df=1, lower=F))
###
topDEG_idx = list()
bottomDEG_idx = list()
for(i in 1:max_PC_idx){
cor_test = cor(test$x[,i], mat)
# print(cor_test)
PRTB_idx = which(abs(cor_test) >= cor_threshold)
topDEG = which(slct_pval[, i] >= 1 - perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
topDEG = topDEG[order(test$x[topDEG, i], decreasing = T)]
bottomDEG = which(slct_pval[, i] <= perm_pval_thres & apply(mat[, PRTB_idx, drop=F], MARGIN = 1, FUN = function(x) any(abs(x) >= z_threshold) ))
bottomDEG = bottomDEG[order(test$x[bottomDEG, i], decreasing = T)]
# determine the orientation by looking at the sums of Z-score
# a positive sum(Z-score) indicates up-regulated genes;
# a negative sum(Z-score) indicates down-regulated genes.
if( sum(mat[topDEG, PRTB_idx]) > sum(mat[bottomDEG, PRTB_idx]) ){
swap = topDEG
topDEG = rev(bottomDEG)
bottomDEG = rev(swap)
rm(swap)
}
topDEG_idx[[paste0("PC", i)]] = topDEG
bottomDEG_idx[[paste0("PC", i)]] = bottomDEG
}
# By default, if k >= 2, we will collapse all the significant genes together
#  and return it to users.
if(collapse == T){
topDEG_idx = Reduce(c, topDEG_idx)
topDEG_idx = topDEG_idx[!duplicated(topDEG_idx)]
bottomDEG_idx = Reduce(c, bottomDEG_idx)
bottomDEG_idx = rev(bottomDEG_idx)
bottomDEG_idx = bottomDEG_idx[!duplicated(bottomDEG_idx)]
return(list(downDEGs = rownames(mat)[topDEG_idx],
upDEGs = rownames(mat)[bottomDEG_idx]))
} else {
downDEGs = list()
upDEGs = list()
for(i in 1:max_PC_idx){
downDEGs[[names(topDEG_idx)[i]]] = rownames(mat)[topDEG_idx[[i]]]
upDEGs[[names(bottomDEG_idx)[i]]] = rev(rownames(mat)[bottomDEG_idx[[i]]])
}
return(list(downDEGs = downDEGs,
upDEGs = upDEGs))
}
}
sig_genes = get_sig_genes(perm_obj = res, k = 2, collapse = F)
str(sig_genes)
sig_genes = get_sig_genes(perm_obj = res, k = 2, collapse = T)
str(sig_genes)
